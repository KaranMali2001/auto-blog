import { defineTable, paginationOptsValidator } from "convex/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";
import { internalMutation, internalQuery } from "../_generated/server";
import { aggregateByTotalBlogCount } from "../aggregation";
import { authenticatedMutation, authenticatedQuery } from "../lib/auth";

export const blogSchema = defineTable({
  title: v.string(),
  content: v.string(),
  status: v.union(v.literal("pending"), v.literal("completed")),
  options: v.optional(
    v.object({
      toneType: v.optional(v.union(v.literal("technical"), v.literal("business"), v.literal("hiring manager"), v.string())),
      length: v.union(v.literal("short"), v.literal("medium"), v.literal("long")),
    }),
  ),
  autoGenerated: v.optional(v.boolean()),
  totalGenerations: v.number(),
  commitIds: v.array(v.id("commits")),
  platform: v.union(v.literal("twitter"), v.literal("linkedin"), v.literal("medium")),
  mediumSource: v.optional(v.union(v.literal("commits"), v.literal("repo"), v.literal("project"))),
  mediumRepoId: v.optional(v.id("repos")),
  userId: v.id("users"),
  createdAt: v.string(),
  updatedAt: v.string(),
  // Versioning fields (optional for backward compatibility with existing blogs)
  version: v.optional(v.number()), // 1, 2, 3, etc.
  parentBlogId: v.optional(v.id("blogs")), // First version's ID (null for first version)
  previousVersionId: v.optional(v.id("blogs")), // Link to previous version
  nextVersionId: v.optional(v.id("blogs")), // Link to next version
})
  .index("byUserId", ["userId"])
  .index("byParentBlogId", ["parentBlogId"]);
export const createBlog = authenticatedMutation({
  args: {
    title: v.optional(v.string()),
    commitIds: v.array(v.id("commits")),
    platform: v.union(v.literal("twitter"), v.literal("linkedin"), v.literal("medium")),
    options: v.optional(
      v.object({
        toneType: v.optional(v.union(v.literal("technical"), v.literal("business"), v.literal("hiring manager"), v.string())),
        length: v.union(v.literal("short"), v.literal("medium"), v.literal("long")),
      }),
    ),
    mediumSource: v.optional(v.union(v.literal("commits"), v.literal("repo"), v.literal("project"))),
    mediumRepoId: v.optional(v.id("repos")),
  },
  handler: async (ctx, args) => {
    const commits = await ctx.db
      .query("commits")
      .withIndex("byUserId", (q) => q.eq("userId", ctx.user._id))
      .collect();

    const isMediumRepoOrProject = args.platform === "medium" && (args.mediumSource === "repo" || args.mediumSource === "project");
    const commitIdsToUse = isMediumRepoOrProject ? [] : args.commitIds;

    const filtered = commits.filter((c) => commitIdsToUse.includes(c._id));
    if (!isMediumRepoOrProject && filtered.length !== args.commitIds.length) {
      throw new Error("Unauthorized: Some commits not found or not owned by user");
    }

    // Prepare commit data for the blog generation
    const commitData = filtered.map((commit) => ({
      commitMessage: commit.commitMessage,
      summarizedCommitDiff: commit.summarizedCommitDiff,
      commitAuthor: commit.commitAuthor || "Unknown Author",
      repoName: commit.commitRepositoryUrl,
      commitDate: new Date(commit._creationTime).toISOString(),
    }));
    // Create blog entry in database
    const blogId = await ctx.db.insert("blogs", {
      title: args.title || "Untitled Post",
      content: "", // Will be updated when action completes
      status: "pending",
      options: {
        toneType: args.options?.toneType || "professional",
        length: args.options?.length || "medium",
      },
      commitIds: commitIdsToUse,
      totalGenerations: 0,
      platform: args.platform,
      mediumSource: args.mediumSource,
      mediumRepoId: args.mediumRepoId,
      userId: ctx.user._id,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: 1, // First version
      parentBlogId: undefined, // First version has no parent
      previousVersionId: undefined,
      nextVersionId: undefined,
    });
    const blog = await ctx.db.get(blogId);
    if (!blog) {
      throw new Error("Failed to retrieve newly created blog");
    }
    await aggregateByTotalBlogCount.insert(ctx, blog);
    await ctx.scheduler.runAfter(0, internal.action_helpers.gemini.generateBlog, {
      blogId: blogId,
      commits: commitData,
      platform: args.platform,
      options: args.options,
      totalGeneration: 0,
      mediumSource: args.mediumSource,
      mediumRepoId: args.mediumRepoId,
    });

    return blogId;
  },
});
export const updateBlogContent = internalMutation({
  args: {
    blogId: v.id("blogs"),
    content: v.string(),
    title: v.string(),
    totalGeneration: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.blogId, {
      content: args.content,
      status: "completed",
      title: args.title,
      totalGenerations: args.totalGeneration,
      updatedAt: new Date().toISOString(),
    });
  },
});
export const getBlogById = authenticatedQuery({
  args: {
    blogId: v.id("blogs"),
  },
  handler: async (ctx, args) => {
    const blog = await ctx.db.get(args.blogId);
    if (!blog || blog.userId !== ctx.user._id) {
      throw new Error("Blog not found or unauthorized");
    }
    return blog;
  },
});

export const getBlogByIdInternal = internalQuery({
  args: {
    blogId: v.id("blogs"),
  },
  handler: async (ctx, args) => {
    const blog = await ctx.db.get(args.blogId);
    if (!blog) {
      throw new Error("Blog not found");
    }
    return blog;
  },
});

export const getBlogs = authenticatedQuery({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, { paginationOpts }) => {
    return await ctx.db
      .query("blogs")
      .withIndex("byUserId", (q) => q.eq("userId", ctx.user._id))
      .order("desc")
      .paginate(paginationOpts);
  },
});

export const deleteBlog = authenticatedMutation({
  args: {
    blogId: v.id("blogs"),
  },
  handler: async (ctx, args) => {
    const blog = await ctx.db.get(args.blogId);
    if (!blog || blog.userId !== ctx.user._id) {
      throw new Error("Blog not found or unauthorized");
    }
    try {
      await aggregateByTotalBlogCount.delete(ctx, blog);
    } catch {
      // Blog may not be in aggregate (e.g. regenerated versions, or pre-aggregate data)
    }
    await ctx.db.delete(args.blogId);
  },
});

export const updateBlog = authenticatedMutation({
  args: {
    blogId: v.id("blogs"),
    title: v.string(),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.blogId, {
      title: args.title,
      content: args.content,
    });
  },
});

export const regenerateBlog = authenticatedMutation({
  args: {
    blogId: v.id("blogs"),
    userInput: v.string(),
    regenerateTitle: v.boolean(),
    regenerateContent: v.boolean(),
  },
  handler: async (ctx, args) => {
    const previousBlog = await ctx.db.get(args.blogId);
    if (!previousBlog || previousBlog.userId !== ctx.user._id) {
      throw new Error("Blog not found or unauthorized");
    }

    // Get the root parent (or use current blog if it's the first version)
    const parentBlogId = previousBlog.parentBlogId || args.blogId;

    // Create a new version
    const newVersion = (previousBlog.version ?? 1) + 1;
    const newBlogId = await ctx.db.insert("blogs", {
      title: previousBlog.title, // Will be updated by action
      content: previousBlog.content, // Will be updated by action
      status: "pending",
      options: previousBlog.options,
      commitIds: previousBlog.commitIds,
      totalGenerations: previousBlog.totalGenerations,
      platform: previousBlog.platform,
      mediumSource: previousBlog.mediumSource,
      mediumRepoId: previousBlog.mediumRepoId,
      userId: ctx.user._id,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: newVersion,
      parentBlogId: parentBlogId,
      previousVersionId: args.blogId,
      nextVersionId: undefined,
    });

    const newBlog = await ctx.db.get(newBlogId);
    if (newBlog) {
      await aggregateByTotalBlogCount.insert(ctx, newBlog);
    }

    // Update previous blog to point to new version
    await ctx.db.patch(args.blogId, {
      nextVersionId: newBlogId,
    });

    // Get commits for regeneration
    const commits = await ctx.db
      .query("commits")
      .withIndex("byUserId", (q) => q.eq("userId", ctx.user._id))
      .collect();

    const filtered = commits.filter((c) => previousBlog.commitIds.includes(c._id));
    const commitData = filtered.map((commit) => ({
      commitMessage: commit.commitMessage,
      summarizedCommitDiff: commit.summarizedCommitDiff,
      commitAuthor: commit.commitAuthor || "Unknown Author",
      repoName: commit.commitRepositoryUrl,
      commitDate: new Date(commit._creationTime).toISOString(),
    }));

    // Get PR summaries if applicable
    const repoIds = previousBlog.commitIds.length > 0 ? [...new Set(filtered.map((c) => c.repoId))] : [];
    const prs =
      repoIds.length > 0
        ? await ctx.db
            .query("pullRequests")
            .filter((q) => q.and(q.eq(q.field("userId"), ctx.user._id), q.neq(q.field("summarizedPrDiff"), undefined)))
            .collect()
        : [];
    const prSummaries = prs
      .filter((pr) => pr.mergedAt && repoIds.includes(pr.repoId))
      .map((pr) => ({ prNumber: pr.prNumber, title: pr.title, repoName: pr.repoUrl, summarizedPrDiff: pr.summarizedPrDiff ?? "" }));

    // Schedule regeneration action
    await ctx.scheduler.runAfter(0, internal.action_helpers.gemini.regenerateBlog, {
      newBlogId: newBlogId,
      previousBlogId: args.blogId,
      userInput: args.userInput,
      regenerateTitle: args.regenerateTitle,
      regenerateContent: args.regenerateContent,
      commits: commitData,
      prSummaries,
      platform: previousBlog.platform,
      options: previousBlog.options,
      mediumSource: previousBlog.mediumSource,
    });

    return newBlogId;
  },
});

export const updateRegeneratedBlogContent = internalMutation({
  args: {
    blogId: v.id("blogs"),
    title: v.string(),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.blogId, {
      title: args.title,
      content: args.content,
      status: "completed",
      updatedAt: new Date().toISOString(),
    });
  },
});

export const getVersionInfo = authenticatedQuery({
  args: { blogId: v.id("blogs") },
  handler: async (ctx, args) => {
    const blog = await ctx.db.get(args.blogId);
    if (!blog || blog.userId !== ctx.user._id) {
      throw new Error("Blog not found or unauthorized");
    }

    // If blog doesn't have version (old blog), treat as V1 with no navigation
    if (!blog.version) {
      return {
        currentVersion: 1,
        totalVersions: 1,
        hasPrevious: false,
        hasNext: false,
        previousVersionId: undefined,
        nextVersionId: undefined,
      };
    }

    // Get parent blog ID (or use current if it's the root)
    const parentBlogId = blog.parentBlogId || args.blogId;

    // Get all versions by querying with parentBlogId OR by getting the root blog
    const allVersions = await ctx.db
      .query("blogs")
      .withIndex("byParentBlogId", (q) => q.eq("parentBlogId", parentBlogId))
      .collect();

    // Include the root blog if current blog is not the root
    if (blog.parentBlogId) {
      const rootBlog = await ctx.db.get(parentBlogId);
      if (rootBlog) {
        allVersions.push(rootBlog);
      }
    }

    // Sort by version number
    allVersions.sort((a, b) => (a.version || 1) - (b.version || 1));

    return {
      currentVersion: blog.version,
      totalVersions: allVersions.length,
      hasPrevious: !!blog.previousVersionId,
      hasNext: !!blog.nextVersionId,
      previousVersionId: blog.previousVersionId,
      nextVersionId: blog.nextVersionId,
    };
  },
});
