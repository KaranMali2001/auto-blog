import { defineTable } from "convex/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";
import { internalMutation } from "../_generated/server";
import { authenticatedQuery } from "../lib/auth";

export const cronHistorySchema = defineTable({
  userCronId: v.id("userCrons"),
  runAt: v.number(), // timestamp in ms
  status: v.union(v.literal("success"), v.literal("failure")),
  message: v.optional(v.string()),
  error: v.optional(v.string()),
  durationMs: v.number(),
  userId: v.id("users"),
})
  .index("byUserCronId", ["userCronId"])
  .index("byRunAt", ["runAt"])
  .index("byUserId", ["userId"]);

export const createCronHistory = internalMutation({
  args: {
    userCronId: v.id("userCrons"),
    status: v.union(v.literal("success"), v.literal("failure")),
    message: v.optional(v.string()),
    error: v.optional(v.string()),
    durationMs: v.number(),
    lastRunAt: v.number(),
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("cronHistories", {
      userCronId: args.userCronId,
      runAt: Date.now(),
      status: args.status,
      message: args.message,
      error: args.error,
      durationMs: args.durationMs,
      userId: args.userId,
    });
  },
});
export const getUserCronHistories = authenticatedQuery({
  args: {},
  handler: async (ctx) => {
    return ctx.db
      .query("cronHistories")
      .withIndex("byUserId", (q) => q.eq("userId", ctx.user._id))
      .collect();
  },
});
export const executeCronJob = internalMutation({
  args: {
    userCronId: v.id("userCrons"),
  },
  handler: async (ctx, args) => {
    const userCron = await ctx.db.get(args.userCronId);
    if (!userCron) {
      throw new Error("User cron not found");
    }
    const startTime = Date.now();
    try {
      const commitSummaryPromises = userCron.selectedRepos.map(async (repoId) => {
        return ctx.db
          .query("commits")
          .withIndex("byRepoId", (q) => q.eq("repoId", repoId))
          .filter((q) => q.eq(q.field("userId"), userCron.userId))
          .filter((q) => q.gte(q.field("_creationTime"), Date.now() - 24 * 60 * 60 * 1000))
          .collect();
      });

      const allCommits = (await Promise.all(commitSummaryPromises)).flat();
      if (allCommits.length === 0) {
        throw new Error("No commits found for today");
      }
      const commitSummaries = allCommits.map((commit) => ({
        summarizedCommitDiff: commit.summarizedCommitDiff || "",
        commitMessage: commit.commitMessage,
        commitAuthor: commit.commitAuthor || "Unknown Author",
        repoName: commit.commitRepositoryUrl,
        commitDate: new Date(commit._creationTime).toISOString(),
      }));
      const commitIds = allCommits.map((commit) => commit._id);

      //generate blog without summary
      const linkedinBlogId = await ctx.db.insert("blogs", {
        userId: userCron.userId,
        title: `Automated Blog - ${new Date().toISOString()}`,
        status: "pending",
        platform: "linkedin",
        totalGenerations: 0,
        autoGenerated: true,
        content: "",
        commitIds: commitIds,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
      const twitterBlogId = await ctx.db.insert("blogs", {
        userId: userCron.userId,
        title: `Automated Blog - ${new Date().toISOString()}`,
        status: "pending",
        platform: "twitter",
        totalGenerations: 0,
        autoGenerated: true,
        content: "",
        commitIds: commitIds,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
      await Promise.all([
        ctx.scheduler.runAfter(0, internal.action_helpers.gemini.generateBlog, {
          blogId: linkedinBlogId,
          commits: commitSummaries,
          platform: "linkedin",

          totalGeneration: 0,
        }),
        ctx.scheduler.runAfter(0, internal.action_helpers.gemini.generateBlog, {
          blogId: twitterBlogId,
          commits: commitSummaries,
          platform: "twitter",
          totalGeneration: 0,
        }),
      ]);

      await ctx.db.insert("cronHistories", {
        userCronId: args.userCronId,
        runAt: startTime,
        status: "success",
        durationMs: Date.now() - startTime,
        userId: userCron.userId,
      });

      // Update lastRunAt on success
      await ctx.db.patch(args.userCronId, {
        lastRunAt: startTime,
      });
    } catch (error) {
      await ctx.db.insert("cronHistories", {
        userCronId: args.userCronId,
        runAt: startTime,
        status: "failure",
        error: error instanceof Error ? error.message : String(error),
        durationMs: Date.now() - startTime,
        userId: userCron.userId,
      });

      // Update lastRunAt even on failure
      await ctx.db.patch(args.userCronId, {
        lastRunAt: startTime,
      });
    }
  },
});
